<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Improved Breakout Scanner</title>
  <style>
    body {
      background-color: #111;
      color: #eee;
      font-family: Arial, sans-serif;
      padding: 20px;
    }
    h1 {
      color: #00ffae;
      font-size: 24px;
    }
    .trade-box {
      background: #1e1e1e;
      border: 1px solid #333;
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 20px;
    }
    .trade-box h2 {
      color: #ffce00;
    }
    .label {
      color: #999;
    }
    #log-console {
      background: #222;
      color: #0f0;
      font-size: 14px;
      padding: 10px;
      margin-top: 20px;
      border: 1px solid #444;
      border-radius: 8px;
      max-height: 200px;
      overflow-y: auto;
      white-space: pre-wrap;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/ccxt@4.1.96/dist/ccxt.browser.js"></script>
</head>
<body>
  <h1>üöÄ Improved Breakout Trade Scanner (15m Binance Spot, Ranks 51‚Äì80)</h1>
  <p>Detects breakout setups with fair value gap (FVG) targets based on real price structure, not fixed %.</p>

  <div id="trades">Loading...</div>
  <div id="log-console">üîç Starting scan...</div>

  <script>
    const container = document.getElementById("trades");
    const logConsole = document.getElementById("log-console");

    function log(msg) {
      logConsole.innerText += `\n${msg}`;
    }

    function countTouches(candles, zone, threshold = 0.003) {
      return candles.filter(c => Math.abs(c.high - zone) / zone < threshold).length;
    }

    function findFVGTargets(candles, breakoutPrice) {
      const fvgCandidates = [];
      for (let i = 5; i < candles.length - 2; i++) {
        const prev = candles[i - 1];
        const curr = candles[i];
        const gap = curr.low - prev.high;

        if (gap > 0.002 * breakoutPrice && curr.low > breakoutPrice) {
          fvgCandidates.push(curr.low);
        }
      }
      return [...new Set(fvgCandidates)].sort((a, b) => a - b).slice(0, 2);
    }

    async function fetchBreakouts() {
      container.innerHTML = "Scanning charts...";
      const exchange = new ccxt.binance();

      let tickers;
      try {
        log("Fetching tickers from Binance...");
        tickers = await exchange.fetchTickers();
      } catch (e) {
        log("Failed to fetch tickers: " + e.message);
        return;
      }

      const usdtPairs = Object.entries(tickers)
        .filter(([symbol]) => symbol.endsWith('/USDT') && !symbol.includes('UP') && !symbol.includes('DOWN'))
        .map(([symbol, data]) => ({ symbol, volume: data.quoteVolume }))
        .sort((a, b) => b.volume - a.volume);

      const candidates = usdtPairs.slice(50, 80);
      const setups = [];

      for (const coin of candidates) {
        try {
          log(`Checking ${coin.symbol}`);
          const ohlcv = await exchange.fetchOHLCV(coin.symbol, '15m', undefined, 100);
          const candles = ohlcv.map(c => ({
            time: c[0], open: c[1], high: c[2], low: c[3], close: c[4], volume: c[5]
          }));

          const recentCandles = candles.slice(-40);
          const highs = recentCandles.slice(0, -1).map(c => c.high);
          const resistance = Math.max(...highs);
          const touchCount = countTouches(recentCandles.slice(0, -1), resistance);
          const last = recentCandles[recentCandles.length - 1];

          const avgVolume = recentCandles.slice(0, -1).reduce((sum, c) => sum + c.volume, 0) / (recentCandles.length - 1);

          const atr = recentCandles.slice(-15).reduce((acc, curr, i, arr) => {
            if (i === 0) return acc;
            const prevClose = arr[i - 1].close;
            const tr = Math.max(curr.high - curr.low, Math.abs(curr.high - prevClose), Math.abs(curr.low - prevClose));
            return acc + tr;
          }, 0) / 14;

          if (
            last.close > resistance &&
            last.volume > avgVolume * 1.5 &&
            touchCount >= 3
          ) {
            const entry = last.close;
            const sl = entry - atr * 1.5;
            const fvgTargets = findFVGTargets(candles, entry);

            setups.push({
              symbol: coin.symbol,
              entry: entry.toFixed(6),
              stop_loss: sl.toFixed(6),
              fvg_targets: fvgTargets.map(x => x.toFixed(6)),
              atr: atr.toFixed(6),
              resistance: resistance.toFixed(6),
              avg_vol: avgVolume.toFixed(2),
              latest_vol: last.volume.toFixed(2),
              touches: touchCount
            });

            log(`‚úÖ Breakout: ${coin.symbol}`);
          }

          if (setups.length >= 5) break;
        } catch (err) {
          log(`‚ùå Error on ${coin.symbol}: ${err.message}`);
        }
      }

      log("‚úÖ Scan complete.");
      setTimeout(() => logConsole.style.display = 'none', 3000);

      container.innerHTML = "";
      if (setups.length === 0) {
        container.innerHTML = "<p>No valid breakout setups now. Check again soon.</p>";
        return;
      }

      setups.forEach(t => {
        container.innerHTML += `
          <div class="trade-box">
            <h2>${t.symbol}</h2>
            <p><span class="label">Entry:</span> ${t.entry}</p>
            <p><span class="label">Resistance:</span> ${t.resistance}</p>
            <p><span class="label">Touches at Resistance:</span> ${t.touches}</p>
            <p><span class="label">Stop Loss:</span> ${t.stop_loss}</p>
            <p><span class="label">FVG Targets:</span> ${t.fvg_targets.join(' ‚Üí ')}</p>
            <p><span class="label">ATR (15m):</span> ${t.atr}</p>
            <p><span class="label">Volume (avg):</span> ${t.avg_vol} ‚Äî <span class="label">Now:</span> ${t.latest_vol}</p>
          </div>
        `;
      });
    }

    fetchBreakouts();
  </script>
</body>
</html>
